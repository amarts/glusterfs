\input texinfo
@setfilename user-guide.info
@settitle GlusterFS 1.3 User Guide
@afourpaper

@direntry
* GlusterFS: (user-guide). GlusterFS distributed filesystem user guide
@end direntry

@copying
This is the user manual for GlusterFS 1.3.

Copyright @copyright{} 2007 Z Research, Inc. Permission is granted to
copy, distribute and/or modify this document under the terms of the
@acronym{GNU} Free Documentation License, Version 1.2 or any later
version published by the Free Software Foundation; with no Invariant
Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the
license is included in the chapter entitled ``@acronym{GNU} Free
Documentation License''.
@end copying

@titlepage
@title GlusterFS 1.3 User Guide [DRAFT]
@subtitle Real Soon Now, 2007
@author Vikas Gorur

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c Info stuff
@ifnottex
@node Top
@top GlusterFS 1.3 User Guide

@insertcopying
@menu
* Acknowledgements::            
* Introduction::                
* Installation and Invocation::  
* Concepts::                    
* Translators::                 
* Usage Scenarios::             
* Performance::                 
* Troubleshooting::             
* GNU Free Documentation Licence::  
* Index::                       

@detailmenu
 --- The Detailed Node Listing ---

Installation and Invocation

* Pre requisites::              
* Getting GlusterFS::           
* Building::                    
* Running GlusterFS::           
* A Tutorial Introduction::     

Running GlusterFS

* Server::                      
* Client::                      

Concepts

* Filesystems in Userspace::                
* Translator::                  
* Volume specification file::   

Translators

* Storage Translators::         
* Client and Server Translators::  
* Clustering Translators::      
* Performance Translators::     
* Features Translators::        
* Miscallaneous Translators::   

Storage Translators

* POSIX::        

Client and Server Translators

* Transport modules::           
* Client protocol::             
* Server protocol::             

Clustering Translators

* Unify::                       
* Automatic File Replication::  
* Stripe::                      

Performance Translators

* Read Ahead::                  
* Write Behind::                
* IO Threads::                  
* IO Cache::                    

Features Translators 

* POSIX Locks::                 
* Fixed ID::                    

Miscallaneous Translators

* ROT-13::                      
* Trace::                       

@end detailmenu
@end menu

@end ifnottex
@c Info stuff end

@contents

@node Acknowledgements
@unnumbered Acknowledgements
GlusterFS continues to be a wonderful and enriching experience for all
of us involved. Anand Babu conceived GlusterFS, and leads its
development.  The development team consists of Anand Avati, Amar
Tumballi, Basavanagowda Kanur, Harshavardhana Ranganath, Krishna
Srinivas, Raghavendra G, and myself. Our @acronym{CEO}, Hitesh
Chellani, ensures we get paid for hacking on GlusterFS.

GlusterFS development would not have been possible at this pace if
not for our enthusiastic users. People from around the world have
helped us with bug reports, performance numbers, and feature suggestions.
A huge thanks to them all.

Matthew Paine - for RPMs & general enthu

Leonardo Rodrigues de Mello - for DEBs

Julian Perez & Adam D'Auria - for multi-server tutorial

Paul England - for HA spec

Brent Nelson - for many bug reports

Jacques Mattheij - for europe mirror.

@flushright
Vikas Gorur (@email{vikas@@zresearch.com})
Z Research
@end flushright

@node Introduction
@chapter Introduction

GlusterFS is a distributed filesystem. It works at the file level,
not block level.

A network filesystem is one which allows us to access remote files. A
distributed filesystem is one that stores data on multiple machines
and makes them all appear to be a part of the same filesystem.

Need for distributed filesystems

@itemize @bullet
@item Scalability: A distributed filesystem allows us to store more data than what can be stored on a single machine.

@item Redundancy: We might want to replicate crucial data on to several machines.

@item Uniform access: One can mount a remote volume (for example your home directory) from any machine and access the same data.
@end itemize

@section Contacting us
You can reach us through the mailing list @strong{gluster-devel} 
(@email{gluster-devel@@nongnu.org}).
@cindex GlusterFS mailing list

You can also find many of the developers on @acronym{IRC}, on the @code{#gluster}
channel on Freenode (@indicateurl{irc.freenode.net}).
@cindex IRC channel, #gluster

For commercial support, you can contact Z Research at:
@cindex commercial support
@cindex Z Research, Inc.

@display
Z Research Inc.,
3194 Winding Vista Common
Fremont, CA 94539
USA.
Phone: +1-510-5346801
Toll free: +18888136309
@end display

You can also email us at @email{support@@zresearch.com}.

@node Installation and Invocation
@chapter Installation and Invocation

@menu
* Pre requisites::              
* Getting GlusterFS::           
* Building::                    
* Running GlusterFS::           
* A Tutorial Introduction::     
@end menu

@node Pre requisites
@section Pre requisites

Before installing GlusterFS make sure you have the
following components installed.

@subsection @acronym{FUSE}
You'll need @acronym{FUSE} version 2.6.0 or higher to
use GlusterFS. You can omit installing @acronym{FUSE} if you want to
build @emph{only} the server. Note that you won't be able to mount
a GlusterFS filesystem on a machine that does not have @acronym{FUSE}
installed.

@acronym{FUSE} can be downloaded from: @indicateurl{http://fuse.sourceforge.net/}

@subsection libibverbs (optional)
@cindex InfiniBand, installation
@cindex libibverbs
This is only needed if you want GlusterFS to use InfiniBand as the
interconnect mechanism between server and client. You can get it from:

@indicateurl{http://www.openfabrics.org/downloads.htm}.

@subsection Bison and Flex
These should be already installed on most Linux systems. We recommend
using @acronym{GNU} Bison and Flex.

@node Getting GlusterFS
@section Getting GlusterFS
@cindex arch
There are many ways to get hold of GlusterFS. For a production deployment,
the recommended method is to download the latest release tarball.
Release tarballs are available at: @indicateurl{http://gluster.org/download.php}.

If you want the bleeding edge development source, you can get them
from the @acronym{GNU}
Arch@footnote{@indicateurl{http://www.gnu.org/software/gnu-arch/}}
repository. First you must install @acronym{GNU} Arch itself. Then
register the GlusterFS archive by doing:

@example
$ tla register-archive http://arch.sv.gnu.org/archives/gluster
@end example

Now you can check out the source itself:

@example
$ tla get -A gluster@@sv.gnu.org glusterfs--mainline--2.5
@end example

@cindex @acronym{RPM} package
If you are on an @acronym{RPM} based system, you can also try @acronym{RPM}s
contributed by Matthew Paine (@email{matt@@mattsoftware.com}), for CentOS 5,
available at: 

@indicateurl{http://www.mattsoftware.com/msw_repo/centos/5/}

@cindex Ubuntu package
Leonardo Rodrigues de Mello (@email{l@@lmello.eu.org}) has created Debian
packages of GlusterFS. They are available at:

@indicateurl{http://lmello.virt-br.org/debian}

@node Building
@section Building
You can skip this section if you're installing from @acronym{RPM}s
or @acronym{DEB}s.

GlusterFS uses the Autotools mechanism to build. As such, the procedure
is straight-forward. First, change into the GlusterFS source directory.

@example
$ cd glusterfs--1.3
@end example

If you checked out the source from the Arch repository, you'll need
to run @command{./autogen.sh} first. Note that you'll need to have
Autoconf and Automake installed for this. 

Run @command{configure}.

@example
$ ./configure
@end example

The configure script accepts the following options:

@cartouche
@table @code

@item --disable-ibverbs
Disable the InfiniBand transport mechanism.

@item --disable-fuse-client
Disable the @acronym{FUSE} client.

@item --disable-server
Disable building of the GlusterFS server.

@end table
@end cartouche

@node Running GlusterFS
@section Running GlusterFS

@menu
* Server::                      
* Client::                      
@end menu

@node Server
@subsection Server
@cindex GlusterFS server

Lorem ipsum some text just
to
fill
up


things

you kn

know


@cartouche
@table @code
@item -f, --spec-file=VOLUMESPEC-FILE   
      Load the VOLUMESPEC-FILE.

@item -l, --log-file=LOGFILE     
      Specify the file to redirect logs

@item -L, --log-level=LOGLEVEL   
      LOGLEVEL should be one of DEBUG, WARNING, [ERROR], CRITICAL, NONE

@item  -N, --no-daemon            
       Run glusterfsd in foreground

@item  -p, --pidfile=PIDFILE      
       Path for the pid file

@item  -?, --help                 
       Give this help list

@item  --usage                
       Give a short usage message

@item  -V, --version              
       display version information
@end table
@end cartouche

@node Client
@subsection Client
@cindex GlusterFS client

@cartouche
@table @code
@item  -a, --attr-timeout=SECONDS 
       Attribute timeout for inodes in the kernel. Defaults to 1 second

@item  -d, --direct-io-mode=ENABLE|DISABLE
       Whether to force directIO on fuse fd. Defaults to ENABLE

@item  -e, --entry-timeout=SECONDS   
       Entry timeout for dentries in the kernel. Defaults to 1 second

@item  -f, --spec-file=VOLUMESPEC-FILE
       Load a local VOLUMESPEC file. Mandatory if --server option is not passed.

@item  -l, --log-file=LOGFILE     
       Specify the file to redirect logs

@item  -L, --log-level=LOGLEVEL   
       LOGLEVEL should be one of DEBUG, WARNING, [ERROR], CRITICAL, NONE

@item  -n, --volume-name=VOLUME-NAME   
       Volume name in client spec to use. Defaults to the topmost volume

@item  -N, --no-daemon            
       Run glusterfs in foreground

@item  -p, --port=PORT            
       Connect to PORT on SERVER

@item  -s, --server=SERVER        
       SERVER to connect to get client specification. One of --server or --spec-file is mandatory.

@item  -t, --transport=TRANSPORT  
       Transport type to get the spec from server

@item  -?, --help                 
       Give this help list

@item  -V, --version              
       print version information
@end table
@end cartouche

@node A Tutorial Introduction
@section A Tutorial Introduction

This section will show you how to quickly get GlusterFS up and running. We'll 
configure GlusterFS as a simple network filesystem, with one server and one client.
In this mode of usage, GlusterFS can serve as a replacement for NFS.

We'll make use of two machines; call them @emph{server} and
@emph{client} (If you don't want to setup two machines, just run
everything that follows on the same machine).  In the examples that
follow, the shell prompts will use these names to clarify the machine
on which the command is being run. For example, a command that should
be run on the server will be shown with the prompt:

@example
[root@@server]#
@end example

Our goal is to make a directory on the @emph{server} (say, @command{/export})
accessible to the @emph{client}.

First of all, get GlusterFS installed on both the machines, as described in the 
previous sections. Make sure you have the @acronym{FUSE} kernel module loaded. You
can ensure this by running: 

@example
[root@@server]# modprobe fuse
@end example

Before we can run the GlusterFS client or server programs, we need to write
two files called @emph{volume specifications}. The volume spec describes the 
@emph{translator tree} on a node. The next chapter will explain the concepts of
`translator' and `volume specification' in detail. For now, just assume that
the volume spec is like an NFS @command{/etc/export} file.

On the server, create a text file somewhere (we'll assume the path
@command{/tmp/glusterfs-server.vol}) with the following contents.

@cartouche
@example
volume colon-o
  type storage/posix
  option directory /export
end-volume

volume server
  type protocol/server
  subvolumes colon-o
  option transport-type tcp/server     
  option auth.ip.colon-o.allow *
end-volume
@end example
@end cartouche

A brief explanation of the file's contents. The first section defines a storage
volume, named ``colon-o'' (the volume names are arbitrary), which exports the
@command{/export} directory. The second section defines options for the translator
which will make the storage volume accessible remotely. It specifies @command{colon-o} as
a subvolume. This defines the @emph{translator tree}, about which more will be said
in the next chapter. The two options specify that the @acronym{TCP} protocol is to be
used (as opposed to InfiniBand, for example), and that access to the storage volume
is to be provided to clients with any @acronym{IP} address at all. If you wanted to
restrict access to this server to only your subnet for example, you'd specify
something like @command{192.168.1.*} in the second option line.

On the client machine, create the following text file (again, we'll assume
the path to be @command{/tmp/glusterfs-client.vol}). Replace
@emph{server-ip-address} with the @acronym{IP} address of your server machine. If you
are doing all this on a single machine, use @command{127.0.0.1}.

@cartouche
@example
volume client
  type protocol/client
  option transport-type tcp/client
  option remote-host @emph{server-ip-address}
  option remote-subvolume colon-o
end-volume
@end example
@end cartouche

Now we need to start both the server and client programs. To start the server:

@example
[root@@server]# glusterfsd -f /tmp/glusterfs-server.vol
@end example

To start the client:

@example
[root@@client]# glusterfs -f /tmp/glusterfs-client.vol /mnt/glusterfs
@end example

You should now be able to see the files under the server's @command{/export} directory
in the @command{/mnt/glusterfs} directory on the client. That's it, GlusterFS is now
working as a network file system.

@node Concepts
@chapter Concepts

@menu
* Filesystems in Userspace::                
* Translator::                  
* Volume specification file::   
@end menu

@node Filesystems in Userspace
@section Filesystems in Userspace

A filesystem is usually implemented in the kernel. Kernel development is much
harder than userspace development. @acronym{FUSE} is a kernel module/library 
that allows us to write a filesystem completely in userspace.

@acronym{FUSE} consists of a kernel module which interacts with the userspace
implementation using a device file @code{/dev/fuse}. When a process 
makes a syscall on a @acronym{FUSE} filesystem, @acronym{VFS} hands the request to the
@acronym{FUSE} module, which writes the request to @code{/dev/fuse}. The
userspace implementation polls @code{/dev/fuse}, and when a request arrives,
processes it and writes the result back to @code{/dev/fuse}. The kernel then
reads from the device file and returns the result to the user process. 

lorem ipsum filler text. lorem ipsum filler text. lorem ipsum filler
text. lorem ipsum filler text. lorem ipsum filler text. lorem ipsum
filler text. lorem ipsum filler text. lorem ipsum filler text. lorem
ipsum filler text. lorem ipsum filler text. lorem ipsum filler
text. lorem ipsum filler text. lorem ipsum filler text. lorem ipsum
filler text. lorem ipsum filler text. lorem ipsum filler text. lorem
ipsum filler text. lorem ipsum filler text. lorem ipsum filler
text. lorem ipsum filler text. lorem ipsum filler text. lorem ipsum
filler text. lorem ipsum filler text. lorem ipsum filler text. lorem
ipsum filler text. lorem ipsum filler text. lorem ipsum filler
text. lorem ipsum filler text. lorem ipsum filler text. lorem ipsum
filler text. lorem ipsum filler text. lorem ipsum filler text. lorem
ipsum filler text. lorem ipsum filler text. lorem ipsum filler
text. lorem ipsum filler text.

@node Translator
@section Translator

The @emph{translator} is the most important concept in GlusterFS. In
fact, GlusterFS is nothing but a collection of translators working
together, forming a translator @emph{tree}.

The idea of a translator is perhaps best understood using an
analogy. Consider the @acronym{VFS} in the Linux kernel. The
@acronym{VFS} abstracts the various filesystem implementations (such
as @acronym{EXT3}, ReiserFS, @acronym{XFS}, etc.) supported by the
kernel. When an application calls the kernel to perform an operation
on a file, the kernel passes the request on to the appropriate
filesystem implementation.

For example, let's say there are two partitions on a Linux machine:
@command{/}, which is an @acronym{EXT3} partition, and @command{/usr},
which is a ReiserFS partition. Now if an application wants to open a
file called, say, @command{/etc/fstab}, then the kernel will
internally pass the request to the @acronym{EXT3} implementation.  If
on the other hand, an application wants to read a file called
@command{/usr/src/linux/CREDITS}, then the kernel will call upon the
ReiserFS implementation to do the job.

The ``filesystem implementation'' objects are analogous to GlusterFS
translators. A GlusterFS translator implements all the filesystem
operations.  Whereas in @acronym{VFS} there is a two-level tree (with
the kernel at the root and all the filesystem implementation as its
children), in GlusterFS there exists a more elaborate tree structure.

We can now define translators more precisely. A GlusterFS translator
is a shared object (@command{.so}) that implements every filesystem
call. GlusterFS translators can be arranged in an arbitrary tree
structure (subject to constraints imposed by the translators). When
GlusterFS receives a filesystem call, it passes it on to the
translator at the root of the translator tree. The root translator may
in turn pass it on to any or all of its children, and so on, until the
leaf nodes are reached. The result of a filesystem call is
communicated in the reverse fashion, from the leaf nodes up to the
root node, and then on to the application.

So what might a translator tree look like?

@break

@center{@image{fuse,44pc,}}
@center Fig 1. GlusterFS control flow

@center{@image{xlator,44pc,}}
@center Fig 2. A sample GlusterFS translator tree

@node Volume specification file
@section Volume specification file
The volume specification file describes the translator tree for both the
server and client programs.

A volume specification file is a sequence of volume definitions.
The syntax of a volume definition is explained below:

@cartouche
@example
@strong{volume} @emph{volume-name}
  @strong{type} @emph{translator-name}
  @strong{option} @emph{option-name} @emph{option-value}
  @dots
  @strong{subvolumes} @emph{subvolume1} @emph{subvolume2} @dots
@strong{end-volume}
@end example

@dots
@end cartouche

@table @asis
@item @emph{volume-name}
  An identifier for the volume. This is just a human-readable name,
and can contain any alphanumeric character. For instance, ``storage-1'', ``colon-o'',
or ``forty-two''.

@item @emph{translator-name}
  Name of one of the available translators. Example: @command{protocol/client},
@command{cluster/unify}.

@item @emph{option-name}
  Name of a valid option for the translator.

@item @emph{option-value}
  Value for the option. Everything following the ``option'' keyword to the end of the
line is considered the value; it is up to the translator to parse it.

@item @emph{subvolume1}, @emph{subvolume2}, @dots
  Volume names of sub-volumes. The sub-volumes must already have been defined earlier 
in the file.
@end table

There are a few rules you must follow when writing a volume specification file:

@itemize
@item Everything following a `@command{#}' is considered a comment and is ignored. Blank lines are also ignored.
@item All names and keywords are case-sensitive.
@item The order of options inside a volume definition does not matter.
@item An option value may not span multiple lines.
@item If an option is not specified, it will assume its default value.
@item A sub-volume must have already been defined before it can be referenced. This means you have to write the specification file ``bottom-up'', starting from the leaf nodes of the translator tree and moving up to the root.
@end itemize

A simple example volume specification file is shown below:

@cartouche
@example
# This is a comment line
volume client
 type protocol/client
 option transport-type tcp/client
 option remote-host localhost      # Also a comment
 option remote-subvolume brick
# The subvolumes line may be absent
end-volume

volume iot
 type performance/io-threads
 option thread-count 4
 subvolumes client
end-volume

volume wb
 type performance/write-behind
 subvolumes iot
end-volume
@end example
@end cartouche

@node Translators
@chapter Translators

@menu
* Storage Translators::         
* Client and Server Translators::  
* Clustering Translators::      
* Performance Translators::     
* Features Translators::        
* Miscallaneous Translators::   
@end menu

This chapter documents all the available GlusterFS translators in detail.
Each translator section will show its name (for example, @command{cluster/unify}),
briefly describe its purpose and workings, and list every option accepted by
that translator and their meaning.

@node Storage Translators
@section Storage Translators

The storage translators form the ``backend'' for GlusterFS. Currently,
the only available storage translator is the @acronym{POSIX}
translator, which stores files on a normal @acronym{POSIX}
filesystem. A pleasant consequence of this is that your data will
still be accessible if GlusterFS crashes or cannot be started.

Other storage backends are planned for the future. One of the possibilities is an
Amazon S3 translator. Amazon S3 is an unlimited online storage service accessible
through a web services @acronym{API}. The S3 translator will allow you to access
the storage as a normal @acronym{POSIX} filesystem.
@footnote{Some more discussion about this can be found at: 

http://developer.amazonwebservices.com/connect/message.jspa?messageID=52873}

@menu
* POSIX::        
@end menu

@node POSIX
@subsection POSIX
@example
type storage/posix
@end example

The @command{posix} translator uses a normal @acronym{POSIX}
filesystem as its ``backend'' to actually store files and
directories. This can be any filesystem that supports extended
attributes (@acronym{EXT3}, ReiserFS, @acronym{XFS}, ...). Extended
attributes are used by some translators to store metadata, for
example, by the @acronym{AFR} and stripe translators. See 
@ref{Automatic File Replication} and @ref{Stripe}, respectively for details.

@cartouche
@table @code
@item directory <path>
The directory on the local filesytem which is to be used for storage.

@item inode-lru-limit <n> (1000)
@end table               
@end cartouche

@node Client and Server Translators, Clustering Translators, Storage Translators, Translators
@section Client and Server Translators

The client and server translator enable GlusterFS to export a
translator tree over the network or access a remote GlusterFS
server. These two translators implement GlusterFS's network protocol.

@menu
* Transport modules::           
* Client protocol::             
* Server protocol::             
@end menu

@node Transport modules
@subsection Transport modules
The client and server translators are capable of using any of the
pluggable transport modules. Currently available transport modules are
@command{tcp}, which uses a @acronym{TCP} connection between client
and server to communicate; @command{ib-sdp}, which uses a
@acronym{TCP} connection over InfiniBand, and @command{ibverbs}, which
uses high-speed InfiniBand connections.

@node TCP
@subsubsection TCP

@cartouche
@table @code
@item non-blocking-connect [no|off|on|yes] (on)

@item remote-port <n> (6996)

@item remote-host <hostname> *
@end table
@end cartouche

@node IB-SDP
@subsubsection IB-SDP
kernel implements socket interface for ib hardware. SDP is over ib-verbs.
This module accepts the same options as @command{tcp}

@node ibverbs
@subsubsection ibverbs

@cindex infiniband transport

The @command{ib-verbs} transport accesses the InfiniBand hardware through
the ``verbs'' @acronym{API}, which is the lowest level of software access possible
and which gives the highest performance. On InfiniBand hardware, it is always
best to use @command{ib-verbs}. Use @command{ib-sdp} only if you cannot get
@command{ib-verbs} working for some reason. 

If you are familiar with InfiniBand jargon,
the mode is used by GlusterFS is ``reliable connection-oriented channel transfer''.

(Mellanox notes).

The @command{ib-verbs} transport module accepts the following options.

@cartouche
@table @code
@item ib-verbs-work-request-send-count <n> (64)
Length of the send queue in datagrams. [Reason to increase/decrease?]

@item ib-verbs-work-request-recv-count <n> (64)
Length of the receive queue in datagrams. [Reason to increase/decrease?]

@item ib-verbs-work-request-send-size <size> (128KB)
Size of each datagram that is sent. [Reason to increase/decrease?]

@item ib-verbs-work-request-recv-size <size> (128KB)
Size of each datagram that is received. [Reason to increase/decrease?]

@item ib-verbs-port <n> (1)
Port number for ib-verbs.

@item ib-verbs-mtu [256|512|1024|2048|4096] (2048)
The Maximum Transmission Unit [Reason to increase/decrease?]

@item ib-verbs-device-name <device-name> (first device in the list)
InfiniBand device to be used.
@end table
@end cartouche

For maximum performance, you should ensure that the send/receive counts on both
the client and server are the same.

ib-verbs is preferred over ib-sdp.

@node Client protocol
@subsection Client
@example
type procotol/client
@end example

client protocol.

@cartouche
@table @code

@item transport-type [tcp,ib-sdp,ib-verbs] (tcp/client)

@item remote-subvolume <volume_name> *
@item inode-lru-limit <n> (1000)
@item transport-timeout <n> (120- seconds)

@end table
@end cartouche

@node Server protocol
@subsection Server
@example
type protocol/server
@end example

@cartouche
@table @code
@item client-volume-filename <path> (<CONFDIR>/glusterfs-client.vol)

@item transport-type [tcp,ib-verbs,ib-sdp] (tcp/server)

@end table
@end cartouche

@node Clustering Translators
@section Clustering Translators

@menu
* Unify::                       
* Automatic File Replication::  
* Stripe::                      
@end menu

@node Unify
@subsection Unify
@cindex unify (translator)
@cindex scheduler (unify)
@cindex rr (scheduler)
@cindex random (scheduler)
@cindex alu (scheduler)
@cindex nufa (scheduler)
@example
type cluster/unify
@end example

unify unifies its subvolumes.
it has children, and will do stuff on them.

scheduler is used for creates. 
 rr, random
 nufa - prefers local. otherwise does rr
 alu - adaptive least usage. Various criteria. order of preference. entry & exit
       threshold.

@subsubsection ALU

ALU stands for "Adaptive Least Usage". It is the most advanced
scheduler available in GlusterFS. It balances the load across volumes,
taking several factors in account. It adapts itself to changing I/O
patterns, according to its configuration. When properly configured, it
can eliminate the need for regular tuning of the filesystem to keep
volume load nicely balanced.

The ALU scheduler is composed of multiple least-usage
sub-schedulers. Each sub-scheduler keeps track of a certain type of
load, for each of the subvolumes, getting the actual statistics from
the subvolumes themselves. The sub-schedulers are these:

disk-usage - the used and free disk space on the volume

read-usage - the amount of reading done from this volume

write-usage - the amount of writing done to this volume

open-files-usage - the number of files currently opened from this volume

disk-speed-usage - the speed at which the disks are spinning. This is
a constant value and therefore not very useful.

The ALU scheduler needs to know which of these sub-schedulers to use,
and in which order to evaluate them. This is done through the 
@command{option alu.order} configuration directive.

Each sub-scheduler needs to know two things: when to kick in (the
entry-threshold), and how long to stay in control (the
exit-threshold). For example: when unifying three disks of 100GB,
keeping an exact balance of disk-usage is not necesary. Instead, there
could be a 1GB margin, which can be used to nicely balance other
factors, such as read-usage. The disk-usage scheduler can be told to
kick in only when a certain threshold of discrepancy is passed, such
as 1GB. When it assumes control under this condition, it will write
all subsequent data to the least-used volume. If it is doing so, it is
unwise to stop right after the values are below the entry-threshold
again, since that would make it very likely that the situation will
occur again very soon. Such a situation would cause the ALU to spend
most of its time disk-usage scheduling, which is unfair to the other
sub-schedulers. The exit-threshold therefore defines the amount of
data that needs to be written to the least-used disk, before control
is relinquished again.

In addition to the sub-schedulers, the ALU scheduler also has "limits"
options. These can stop the creation of new files on a volume once
values drop below a certain threshold. For example, setting "option
alu.limits.min-free-disk 5%" will stop the scheduling of files to
volumes that have less than 5% of free disk space, leaving the files
on that disk some room to grow.

The actual values you assign to the thresholds for sub-schedulers and
limits depend on your situation. If you have fast-growing files,
you'll want to stop file-creation on a disk much earlier than when
hardly any of your files are growing. If you care less about
disk-usage balance than about read-usage balance, you'll want a bigger
disk-usage scheduler entry-threshold and a smaller read-usage
scheduler entry-threshold.

For thresholds defining a size, values specifying "KB", "MB" and "GB"
are allowed. For example: @command{option alu.limits.min-free-disk 5GB}.

@cartouche
@table @code
@item alu.order <order> * ("disk-usage:write-usage:read-usage:open-files-usage:disk-speed")
@item alu.disk-usage.entry-threshold <size> (1GB)
@item alu.disk-usage.exit-threshold <size> (512MB)
@item alu.write-usage.entry-threshold <%> (25)
@item alu.write-usage.exit-threshold <%> (5)
@item alu.read-usage.entry-threshold <%> (25)
@item alu.read-usage.exit-threshold <%> (5)
@item alu.open-files-usage.entry-threshold <n> (1000)
@item alu.open-files-usage.exit-threshold <n> (100)
@item alu.limits.min-free-disk <%> 
@item alu.limits.max-open-files <n> 
@end table
@end cartouche

@subsubsection Round Robin (RR)

Round-Robin (RR) scheduler creates files in a round-robin
fashion. Each client will have its own round-robin loop. When your
files are mostly similar in size and I/O access pattern, this
scheduler is a good choice. RR scheduler now checks for free disk size
of the server before scheduling, so you can know when to add
another server brick. The default value of min-free-disk is 5% and is
checked every 10 seconds (by default) if there is any create call
happening.

@cartouche
@table @code
@item rr.limits.min-free-disk <%> (5)
@item rr.refresh-interval <t> (10 seconds)
@end table
@end cartouche

@cartouche
@table @code
@item random.limits.min-free-disk <%> (5)
@item random.refresh-interval <t> (10 seconds)
@end table
@end cartouche

@subsubsection NUFA

Non-Uniform Filesystem Scheduler similar to NUMA
@footnote{http://en.wikipedia.org/wiki/Non-Uniform_Memory_Access}
memory design. It is mainly used in HPC environments where you are
required to run the filesystem server and client within the same
cluster. Under such environment, NUFA scheduler gives the local system
first priority for file creation over other nodes.

@cartouche
@table @code
@item nufa.limits.min-free-disk <%> (5)
@item nufa.refresh-interval <t> (10 seconds)
@item nufa.local-volume-name <volume> 
@end table
@end cartouche

@cindex namespace
@subsubsection Namespace
Namespace volume needed because:
 - persistent inode numbers.
 - file exists even when node is down.

namespace files are simply touched. on every lookup it is checked.

@cindex self heal (unify)
@subsubsection Self Heal
Self heal:
 two rules:
   - dir structure should be consistent.
   - file should exist on only one node.

@cartouche
@table @code
@item namespace <volume> *
@item self-heal [on|off] (on)
@item inode-lru-limit <n> (1000)
@end table
@end cartouche

@node Automatic File Replication
@subsection Automatic File Replication (AFR)
@cindex automatic file replication (@acronym{AFR})
@example
type cluster/afr
@end example

AFR provides RAID-1 like functionality. AFR replicates files and directories
across the subvolumes. Hence if AFR has four subvolumes, there will be four
copies of all files and directories. AFR provides HA, i.e in case one of the
subvolumes go down (ex. server crash, network disconnection) AFR will still
service the requests from the redundant copies.

AFR also provides self-heal functionality, i.e in case the crashed servers
comeup, the outdated files and directories will be updated with the
latest versions. AFR uses extended attributes of the backend file system
to track the versioning of files and directories to provide the self-heal
feature.

* Note that previously supported "option replicate *html:2,*txt:1" pattern
 matching feature is moved out of AFR. It will be provided as a separate
 translator in 1.4

volume afr-example
 type cluster/afr
 subvolumes brick1 brick2 brick3
end-volume

This sample configuration will replicate all directories and files on brick1,
brick2 and brick3. The subvolumes can be another translator (storage/posix
or protocol/client)

All the read() operations happen from the first alive child. If all the
three subvols are up, read() will be done on brick1, if brick1 is down
read() will be done on brick2. In case read() was being done on brick1
and it goes down, we fallback to brick2 which will be completely
transparent to the user applications.

In 1.4 we will have:
* a feature where user can specify the subvol from which AFR has
 to do read() operations (this will help users who have one of the
 subvols as local storage/posix)
* feature to allow scheduling of read() operations amongst the
 subvols in round-robin fashion.

The order of the subvolumes list should be same across all the AFRs
as they will be used as lock servers. TODO: details on working of locking.

@subsubsection Self Heal
AFR has self-heal feature, which updates the outdated file and directory
copies by the most recent versions. For example consider the following
config:

volume afr-example
 type cluster/afr
 subvolumes brick1 brick2
end-volume

File self-heal
Now if we create a file foo.txt on afr-example, the file will be created
on brick1 and brick2. The file will have two extended attributes associated
with it in the backend filesystem. One is trusted.afr.createtime and the
other is trusted.afr.version. The trusted.afr.createtime xattr has the
create time (in terms of seconds since epoch) and trusted.afr.version
is a number that is incremented each time a file is modified. This increment
happens during close (incase any write was done before close).

If brick1 goes down, we edit foo.txt the version gets incremented. Now
the brick1 comes back up, when we open() on foo.txt AFR will check if
their versions are same. If they are not same, the outdated copy is
replaced by the latest copy and its version is updated. After the sync
the open() proceeds in the usual manner and the application calling open()
can continue on its access to the file.

If brick1 goes down, we delete foo.txt and create a file with the same
name again i.e foo.txt. Now brick1 comes back up, clearly there is a
chance that the version on brick1 being more than the version on brick2,
this is where createtime extended attribute helps in deciding which
the outdated copy is. Hence we need to consider both createtime and
version to decide on the latest copy.

The version attribute is incremented during the close() call. Version
will not be incremented in case there was no write() done. In case the
fd that the close() gets was got by create() call, we also create
the createtime extended attribute.

Directory self-heal
Suppose brick1 goes down, we delete foo.txt, brick1 comes back up, now
we should not create foo.txt on brick2 but we should delete foo.txt
on brick1. We handle this situation by having the createtime and version
attribute on the directory similar to the file. when lookup() is done
on the directory, we compare the createtime/version attributes of the
copies and see which files needs to be deleted and delete those files
and update the extended attributes of the outdated directory copy.
Each time a directory is modified (a file or a subdirectory is created
or deleted inside the directory) and one of the subvols is down, we
increment the directory's version.

lookup() is a call initiated by the kernel on a file or directory
just before any access to that file or directory. In glusterfs, by
default, lookup() will not be called in case it was called in the
past one second on that particular file or directory.

The extended attributes can be seen in the backend filesystem using
the getfattr command. (getfattr -n trusted.afr.version <file>)

@cartouche
@table @code
@item debug [on|off]  (off)
@item self-heal [on|off] (on)
@item replicate <pattern> (*:1)
@item lock-node <child_volume> (first_child)
@item inode-lru-limit <n> (1000)
@end table
@end cartouche

@node Stripe
@subsection Stripe
@cindex stripe (translator)
@example
type cluster/stripe
@end example

uses extended attrs to store info.

@cartouche
@table @code
@item inode-lru-limit <n> (1000)
@item block-size <pattern> (*:0 no striping)
@end table
@end cartouche

@node Performance Translators
@section Performance Translators

@menu
* Read Ahead::                  
* Write Behind::                
* IO Threads::                  
* IO Cache::                    
@end menu

@node Read Ahead
@subsection Read Ahead
@cindex read-ahead (translator)
@example
type performance/read-ahead
@end example

The read-ahead translator pre-fetches data in advance on every read.
This benefits applications that mostly process files in sequential order,
since the next block of data will already be available by the time the
application is done with the current one. 

Additionally, the read-ahead translator also behaves as a read-aggregator. 
Many small read operations are combined and issued as fewer, larger read
requests to the server.

Read-ahead deals in ``pages'' as the unit of data fetched. The page size
is configurable, as is the ``page count'', which is the number of pages
that are pre-fetched.

Read-ahead is best used with InfiniBand (using the ib-verbs transport,
@pxref{ibverbs}). On FastEthernet and Gigabit Ethernet networks,
GlusterFS can achieve the link-maximum throughput even without
read-ahead, making it quite superflous.

Note that read-ahead only happens if the reads are perfectly
sequential. If your application accesses data in a random fashion,
using read-ahead might actually lead to a performance loss, since
read-ahead will pointlessly fetch pages which won't be used by the
application.

@cartouche
Options:
@table @code
@item page-size <n> (256KB)
The unit of data that is pre-fetched.
@item page-count <n> (2)
The number of pages that are pre-fetched.
@item force-atime-update [on|off|yes|no] (off|no)
Whether to force an access time (atime) update on the file on every read. Without
this, the atime will be slightly imprecise, as it will reflect the time when 
the read-ahead translator read the data, not when the application actually read it.
@end table
@end cartouche

@node Write Behind
@subsection Write Behind
@cindex write-behind (translator)
@example
type performance/write-behind
@end example

The write-behind translator improves the latency of a write operation.
It does this by relegating the write operation to the background and
returning to the application even as the write is in progress. Using the
write-behind translator, successive write requests can be pipelined.
This mode of write-behind operation is best used on the client side, to
enable decreased write latency for the application.

The write-behind translator can also aggregate write requests. If the 
@command{aggregate-size} option is specified, then successive writes upto that
size are accumulated and written in a single operation. This mode of operation
is best used on the server side, as this will decrease the disk's head movement
when multiple files are being written to in parallel.

The @command{aggregate-size} option has a default value of 128KB. Although
this works well for most users, you should always experiment with different values
to determine the one that will deliver maximum performance. This is because the
performance of write-behind depends on your interconnect, size of RAM, and the
work load.

@cartouche
@table @code
@item aggregate-size <n> (128KB)
Amount of data to accumulate before doing a write
@item flush-behind [on|yes|off|no] (off|no)

@end table
@end cartouche

@node IO Threads
@subsection IO Threads
@cindex io-threads (translator)
@example
type performance/io-threads
@end example

The IO threads translator is intended to increase the responsiveness
of the server to metadata operations by doing file I/O (read, write)
in a background thread.  Since the GlusterFS server is
single-threaded, using the IO threads translator can significantly
improve performance. This translator is best used on the server side,
loaded just below the server protocol translator.

IO threads operates by handing out read and write requests to a separate thread.
The total number of threads in existence at a time is constant, and configurable.
You can also set a maximum limit on the amount of data to be queued with IO threads,
using the @command{cache-size} option. If more than @command{cache-size} worth of
operations are pending, any further requests will block.

@cartouche
@table @code
@item thread-count <n> (1)
Number of threads to use.
@item cache-size <n> (64MB)
Maximum amount of data allowed to be pending inside io-threads.
@end table
@end cartouche

@node IO Cache
@subsection IO Cache
@cindex io-cache (translator)
@example
type performance/io-cache
@end example

The IO cache translator caches data that has been read. This is useful
if many applications read the same data multiple times, and if reads
are much more frequent than writes (for example, IO caching may be
useful in a web hosting environment, where most clients will simply
read some files and only a few will write to them).

The IO cache translator reads data from its child in @command{page-size} chunks.
It caches data upto @command{cache-size} bytes. The cache is maintained as
a prioritized least-recently-used (@acronym{LRU}) list, with priorities determined
by user-specified patterns to match filenames.

When the IO cache translator detects a write operation, the 
cache for that file is flushed.

The IO cache translator periodically verifies the consistency of
cached data, using the modification times on the files. The verification timeout
is configurable.

@cartouche
@table @code
@item page-size <n> (128KB)
Size of a page.
@item cache-size (n) (32MB)
Total amount of data to be cached.
@item force-revalidate-timeout <n> (1)
Timeout to force a cache consistency verification, in seconds.
@item priority <pattern> (*:0)
Filename patterns listed in order of priority.
@end table
@end cartouche

@subsection Booster
@node Booster
@cindex booster
@example
  type performance/booster
@end example

The booster translator gives applications a faster path to communicate
read and write requests to GlusterFS. Normally, all requests to GlusterFS from
applications go through FUSE, as indicated in @ref{Filesystems in Userspace}.
Using the booster translator in conjunction with the GlusterFS booster shared
library, an application can bypass the FUSE path and send read/write requests
directly to the GlusterFS client process.

The booster mechanism consists of two parts: the booster translator,
and the booster shared library. The booster translator is meant to be
loaded on the client side, usually at the root of the translator tree.
The booster shared library should be @command{LD_PRELOAD}ed with the
application.

The booster translator when loaded opens a Unix domain socket and
listens for read/write requests on it. The booster shared library
intercepts read and write system calls and sends the requests to the
GlusterFS process directly using the Unix domain socket, bypassing FUSE.
This leads to superior performance.

Once you've loaded the booster translator in your volume specification file, you
can start your application as:

@example
  $ LD_PRELOAD=/usr/local/bin/glusterfs-booster.so your_app
@end example

The booster translator accepts no options.

@node Features Translators
@section Features Translators 

@menu
* POSIX Locks::                 
* Fixed ID::                    
@end menu

@node POSIX Locks
@subsection POSIX Locks
@cindex record locking
@cindex fcntl
@cindex posix-locks (translator)
@example
type features/posix-locks
@end example

This translator provides storage independent POSIX record locking
support (fcntl locking). Typically you'll want to load this on the
server side, just above the @acronym{POSIX} storage translator. Using this
translator you can get both advisory locking and mandatory locking
support.  @command{flock()} locks are currently not supported.

Caveat: Consider a file that does not have its mandatory locking bits
(+setgid, -group execution) turned on. Assume that this file is now
opened by a process on a client that has the write-behind xlator
loaded. The write-behind xlator does not cache anything for files
which have mandatory locking enabled, to avoid incoherence. Let's say
that mandatory locking is now enabled on this file through another
client. The former client will not know about this change, and
write-behind may erroneously report a write as being successful when
in fact it would fail due to the region it is writing to being locked.

There seems to be no easy way to fix this. To work around this
problem, it is recommended that you never enable the mandatory bits on
a file while it is open.

@cartouche
@table @code
@item mandatory [on|off] (on)
Turns mandatory locking on.
@end table
@end cartouche

@node Fixed ID
@subsection Fixed ID
@cindex fixed-id (translator)
@example
type features/fixed-id
@end example

The fixed ID translator makes all filesystem requests from the client
to appear to be coming from a fixed, specified
@acronym{UID}/@acronym{GID}, regardless of which user actually
initiated the request.

@cartouche
@table @code
@item fixed-uid <n> [if not set, not used]
The @acronym{UID} to send to the server
@item fixed-gid <n> [if not set, not used]
The @acronym{GID} to send to the server
@end table
@end cartouche

@node Miscallaneous Translators
@section Miscallaneous Translators

@menu
* ROT-13::                      
* Trace::                       
@end menu

@node ROT-13
@subsection ROT-13
@cindex rot-13 (translator)
@example
type encryption/rot-13
@end example

@acronym{ROT-13} is a toy translator that can ``encrypt'' and ``decrypt'' file
contents using the @acronym{ROT-13} algorithm. @acronym{ROT-13} is a trivial
algorithm that rotates each alphabet by thirteen places. Thus, 'A' becomes 'N',
'B' becomes 'O', and 'Z' becomes 'M'.

It goes without saying that you shouldn't use this translator if you need 
@emph{real} encryption (a future release of GlusterFS will have real encryption
translators).

@cartouche
@table @code
@item encrypt-write [on|off] (on)
Whether to encrypt on write
@item decrypt-read [on|off] (on)
Whether to decrypt on read
@end table
@end cartouche

@node Trace
@subsection Trace
@cindex trace (translator)
@example
type debug/trace     
@end example

The trace translator is intended for debugging purposes. When loaded, it
logs all the system calls received by the server or client (wherever
trace is loaded), their arguments, and the results. You must use a GlusterFS log
level of DEBUG (See @ref{Running GlusterFS}) for trace to work.

Sample trace output (lines have been wrapped for readability):
@cartouche
@example
2007-10-30 00:08:58 D [trace.c:1579:trace_opendir] trace: callid: 68 
(*this=0x8059e40, loc=0x8091984 @{path=/iozone3_283, inode=0x8091f00@}, 
 fd=0x8091d50)

2007-10-30 00:08:58 D [trace.c:630:trace_opendir_cbk] trace: 
(*this=0x8059e40, op_ret=4, op_errno=1, fd=0x8091d50)

2007-10-30 00:08:58 D [trace.c:1602:trace_readdir] trace: callid: 69 
(*this=0x8059e40, size=4096, offset=0 fd=0x8091d50)

2007-10-30 00:08:58 D [trace.c:215:trace_readdir_cbk] trace: 
(*this=0x8059e40, op_ret=0, op_errno=0, count=4)

2007-10-30 00:08:58 D [trace.c:1624:trace_closedir] trace: callid: 71 
(*this=0x8059e40, *fd=0x8091d50)

2007-10-30 00:08:58 D [trace.c:809:trace_closedir_cbk] trace: 
(*this=0x8059e40, op_ret=0, op_errno=1)
@end example
@end cartouche

@node Usage Scenarios
@chapter Usage Scenarios
- usage as network filesystem
- clustering with four bricks (Julian Perez example, multi-server config example)

@section Advanced Striping

@subsection Mixed Storage Requirements

There are two ways of scheduling the I/O. One at file level (using
unify translator) and other at block level (using stripe
translator). Striped I/O is good for files that are potentially large
and require high parallel throughput (for example, a single file of
400GB being accessed by 100s and 1000s of systems simultaneously and
randomly). For most of the cases, file level scheduling works best.

In the real world, it is desirable to mix file level and block level
scheduling on a single storage volume. Alternatively users can choose
to have two separate volumes and hence two mount points, but the
applications may demand a single storage system to host both.

This document explains how to mix file level scheduling with stripe. 

@subsection Configuration Brief

This setup demonstrates how users can configure unify translator with
appropriate I/O scheduler for file level scheduling and strip for only
matching patterns. This way, GlusterFS chooses appropriate I/O profile
and knows how to efficiently handle both the types of data.

A simple technique to achieve this effect is to create a stripe set of
unify and stripe blocks, where unify is the first sub-volume. Files
that do not match the stripe policy passed on to first unify
sub-volume and inturn scheduled arcoss the cluster using its file
level I/O scheduler.

@subsection Preparing GlusterFS Envoronment

Create the directories /export/namespace, /export/unify and
/export/stripe on all the storage bricks.

 Place the following server and client volume spec file under
/etc/glusterfs (or appropriate installed path) and replace the IP
addresses / access control fields to match your environment.

@cartouche
@example
  ## file: /etc/glusterfs/glusterfs-server.vol
   volume posix-unify
           type storage/posix
           option directory /export/for-unify
   end-volume
 
   volume posix-stripe
           type storage/posix
           option directory /export/for-stripe
   end-volume
 
   volume posix-namespace
           type storage/posix
           option directory /export/for-namespace
   end-volume
  
   volume server
           type protocol/server
           option transport-type tcp/server
           option auth.ip.posix-unify.allow 192.168.1.*
           option auth.ip.posix-stripe.allow 192.168.1.*
           option auth.ip.posix-namespace.allow 192.168.1.*
           subvolumes posix-unify posix-stripe posix-namespace
   end-volume
@end example
@end cartouche

@cartouche
@example
 ## file: /etc/glusterfs/glusterfs-client.vol
   volume client-namespace
     type protocol/client
     option transport-type tcp/client
     option remote-host 192.168.1.1
     option remote-subvolume posix-namespace
   end-volume

   volume client-unify-1
     type protocol/client
     option transport-type tcp/client
     option remote-host 192.168.1.1
     option remote-subvolume posix-unify
   end-volume

   volume client-unify-2
     type protocol/client
     option transport-type tcp/client
     option remote-host 192.168.1.2
     option remote-subvolume posix-unify
   end-volume

   volume client-unify-3
     type protocol/client
     option transport-type tcp/client
     option remote-host 192.168.1.3
     option remote-subvolume posix-unify
   end-volume

   volume client-unify-4
     type protocol/client
     option transport-type tcp/client
     option remote-host 192.168.1.4
     option remote-subvolume posix-unify
   end-volume
 
   volume client-stripe-1
     type protocol/client
     option transport-type tcp/client
     option remote-host 192.168.1.1
     option remote-subvolume posix-stripe
   end-volume

   volume client-stripe-2
     type protocol/client
     option transport-type tcp/client
     option remote-host 192.168.1.2
     option remote-subvolume posix-stripe
   end-volume

   volume client-stripe-3
     type protocol/client
     option transport-type tcp/client
     option remote-host 192.168.1.3
     option remote-subvolume posix-stripe
   end-volume

   volume client-stripe-4
     type protocol/client
     option transport-type tcp/client
     option remote-host 192.168.1.4
     option remote-subvolume posix-stripe
   end-volume
  
   volume unify
     type cluster/unify
     option scheduler rr
     subvolumes cluster-unify-1 cluster-unify-2 cluster-unify-3 cluster-unify-4
   end-volume
 
   volume stripe
     type cluster/stripe
     option block-size *.img:2MB # All files ending with .img are striped with 2MB stripe block size.
     subvolumes unify cluster-stripe-1 cluster-stripe-2 cluster-stripe-3 cluster-stripe-4
   end-volume
@end example
@end cartouche

Bring up the Storage

Starting GlusterFS Server: If you have installed through binary
package, you can start the service through init.d startup script. If
not:

@example
[root@@server]# glusterfsd
@end example

Mounting GlusterFS Volumes:

@example
[root@@client]# glusterfs -s [BRICK-IP-ADDRESS] /mnt/cluster
@end example

Improving upon this Setup

Infiniband Verbs RDMA transport is much faster than TCP/IP GigE
transport.

Use of performance translators such as read-ahead, write-behind,
io-cache, io-threads, booster is recommended.

Replace round-robin (rr) scheduler with ALU to handle more dynamic
storage environments.

@section High Availability setup

- HA setup (from HA tutorial by Paul England)

- encrypted glusterfs setup using ssh tunnels.

- Vserver guest (actually need a better organization for both tunneled setup and 
vserver thing)

@node Performance
@chapter Performance
- effect of direct_io mode.

@section glfs4 patched fuse
channel size between fuse kernel module and libfuse tuned to 1MB

kernel read-ahead boundry extended upto 1MB

st_blksize returned in stat()/fstat() tuned to 1MB, to make cp and
similar commands perform I/O in that block size

flock() locking support [note: needs some rework in glusterfs for perfect compliance]

@section DNS failover
GlusterFS client will try connecting to all the IP addresses of a
hostname in round-robin fashion. Using this you can implement
failover.

@node Troubleshooting
@chapter Troubleshooting

@section GlusterFS error messages
@node GlusterFS error messages

@subsection Server errors
@node Server errors
@example
glusterfsd: FATAL: could not open specfile: 
'/etc/glusterfs/glusterfs-server.vol'
@end example

glusterfsd server requires volume specification file under
/etc/glusterfs/glusterfs-server.vol. Default installation will only
provide /etc/glusterfs/glusterfs-server.vol.sample sample file. You
need to copy it to /etc/glusterfs/glusterfs-server.vol actual file.

@example
gf_log_init: failed to open logfile "/usr/var/log/glusterfs/glusterfsd.log" 
             (Permission denied)
@end example

Check if you are running as root user. Use 'whoami' utility. 

@subsection Client errors
@node Client errors
@example
 fusermount: failed to access mountpoint /mnt: 
             Transport endpoint is not connected
@end example

umount /mnt and mount again.

Error "Transport endpoint is not connected"

GlusterFS mount failed. Start glusterfs client in DEBUG mode and look out for descriptive error messages.

connect to server failed

SERVER-ADDRESS: Connection refused

GluserFS Server is not running or dead. Also check your network connections or firewall settings. To check if the server is reachable, try the following command:

telnet IP-ADDRESS 6996

If server is accessible, your 'telnet' command should connect and block. If not you will see an error message like telnet: Unable to connect to remote host: Connection refused. '6996' is the default GlusterFS port. If you have customized it, then use the corresponding port instead.

gf_log_init: failed to open logfile "/usr/var/log/glusterfs/glusterfs.log" (Permission denied)

glusterfs: failed to open logfile "/usr/var/log/glusterfs/glusterfs.log"

Check if you are running as root user. Use 'whoami' utility. 

@section FUSE error messages
@command{modprobe} fuse fails with "Unknown symbol in module, or unknown parameter".
@cindex Redhat Enterprise Linux

If you are using fuse-2.6.x on Redhat Enterprise Linux Work Station 4
and Advanced Server 4 with 2.6.9-42.ELlargesmp, 2.6.9-42.ELsmp,
2.6.9-42.EL kernels and get this error while loading fuse kernel
module, you need to apply the following patch.

For fuse-2.6.2:

@indicateurl{http://ftp.zresearch.com/pub/gluster/glusterfs/fuse/fuse-2.6.2-rhel-build.patch}

For fuse-2.6.3:

@indicateurl{http://ftp.zresearch.com/pub/gluster/glusterfs/fuse/fuse-2.6.3-rhel-build.patch}

@section AppArmour and GlusterFS
@cindex AppArmour
@cindex OpenSuSE
Under OpenSuSE GNU/Linux, AppArmour security feature did not allow
GlusterFS to create temporary files or network socket connection even
as root user. You will see the error messages like Unable to open log
file: Operation not permitted or Connection refused error. Disabling
apparmour using YaST tool or properly configuring apparmour to
recognize glusterfsd or glusterfs / fusermount should solve the
problem.

GlusterFS log files. 

@section Reporting a bug

If you encounter a bug in GlusterFS, please follow the below
guidelines when you report it to the mailing list. Be sure to report
it! User feedback is crucial to the health of the project and we value
it highly.

@subsection General instructions

When running GlusterFS in a non-production environment, be sure to
build it with the following command:

@example
 $ make CFLAGS='-g -O0 -DDEBUG'
@end example

This includes debugging information which will be helpful in getting
backtraces (see below) and also disable optimization. Enabling
optimization can result in incorrect line numbers being reported to
gdb.

@subsection Volume specification files

Attach all relevant server and client spec files you were using when
you encountered the bug. Also tell us details of your setup, i.e., how
many clients and how many servers.

@subsection Log files

Set the loglevel of your client and server programs to DEBUG (by
passing the -L DEBUG option) and attach the log files with your bug
report. Obviously, if only the client is failing (for example), you
only need to send us the client log file.

@subsection Backtrace

If GlusterFS has encountered a segmentation fault or has crashed for
some other reason, include the backtrace with the bug report. You can
get the backtrace using the following procedure.

Run the GlusterFS client or server inside gdb.

@example
 $ gdb ./glusterfs
 (gdb) set args -f client.spec -N -l/path/to/log/file -LDEBUG /mnt/point
 (gdb) run
@end example

Now when the process segfaults, you can get the backtrace by typing:

@example
 (gdb) bt
@end example

If the GlusterFS process has crashed and dumped a core file (you can
find this in / if running as a daemon and in the current directory
otherwise), you can do:

@example
 $ gdb /path/to/glusterfs /path/to/core.<pid>
@end example

and then get the backtrace.

If the GlusterFS server or client seems to be hung, then you can get
the backtrace by attaching gdb to the process. First get the PID of
the process (using ps), and then do:

@example
 $ gdb ./glusterfs <pid>
@end example

Press Ctrl-C to interrupt the process and then generate the backtrace.

@subsection Reproducing the bug

If the bug is reproducible, please include the steps necessary to do
so. If the bug is not reproducible, send us the bug report anyway.

@subsection Other information

If you think it is relevant, send us also the version of FUSE you're
using, the kernel version, platform.

@node GNU Free Documentation Licence
@appendix GNU Free Documentation Licence
@include fdl.texi

@node Index
@unnumbered Index
@printindex cp

@bye
